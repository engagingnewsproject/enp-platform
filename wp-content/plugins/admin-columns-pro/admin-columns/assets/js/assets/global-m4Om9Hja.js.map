{"version":3,"file":"global-m4Om9Hja.js","sources":["../../../src/node_modules/svelte/src/runtime/store/index.js","../../../src/js/helpers/global.ts"],"sourcesContent":["import {\n\trun_all,\n\tsubscribe,\n\tnoop,\n\tsafe_not_equal,\n\tis_function,\n\tget_store_value\n} from '../internal/index.js';\n\nconst subscriber_queue = [];\n\n/**\n * Creates a `Readable` store that allows reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#readable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Readable<T>}\n */\nexport function readable(value, start) {\n\treturn {\n\t\tsubscribe: writable(value, start).subscribe\n\t};\n}\n\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#writable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Writable<T>}\n */\nexport function writable(value, start = noop) {\n\t/** @type {import('./public.js').Unsubscriber} */\n\tlet stop;\n\t/** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */\n\tconst subscribers = new Set();\n\t/** @param {T} new_value\n\t * @returns {void}\n\t */\n\tfunction set(new_value) {\n\t\tif (safe_not_equal(value, new_value)) {\n\t\t\tvalue = new_value;\n\t\t\tif (stop) {\n\t\t\t\t// store is ready\n\t\t\t\tconst run_queue = !subscriber_queue.length;\n\t\t\t\tfor (const subscriber of subscribers) {\n\t\t\t\t\tsubscriber[1]();\n\t\t\t\t\tsubscriber_queue.push(subscriber, value);\n\t\t\t\t}\n\t\t\t\tif (run_queue) {\n\t\t\t\t\tfor (let i = 0; i < subscriber_queue.length; i += 2) {\n\t\t\t\t\t\tsubscriber_queue[i][0](subscriber_queue[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t\tsubscriber_queue.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {import('./public.js').Updater<T>} fn\n\t * @returns {void}\n\t */\n\tfunction update(fn) {\n\t\tset(fn(value));\n\t}\n\n\t/**\n\t * @param {import('./public.js').Subscriber<T>} run\n\t * @param {import('./private.js').Invalidator<T>} [invalidate]\n\t * @returns {import('./public.js').Unsubscriber}\n\t */\n\tfunction subscribe(run, invalidate = noop) {\n\t\t/** @type {import('./private.js').SubscribeInvalidateTuple<T>} */\n\t\tconst subscriber = [run, invalidate];\n\t\tsubscribers.add(subscriber);\n\t\tif (subscribers.size === 1) {\n\t\t\tstop = start(set, update) || noop;\n\t\t}\n\t\trun(value);\n\t\treturn () => {\n\t\t\tsubscribers.delete(subscriber);\n\t\t\tif (subscribers.size === 0 && stop) {\n\t\t\t\tstop();\n\t\t\t\tstop = null;\n\t\t\t}\n\t\t};\n\t}\n\treturn { set, update, subscribe };\n}\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>, set: (value: T) => void, update: (fn: import('./public.js').Updater<T>) => void) => import('./public.js').Unsubscriber | void} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>) => T} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * @template {import('./private.js').Stores} S\n * @template T\n * @param {S} stores\n * @param {Function} fn\n * @param {T} [initial_value]\n * @returns {import('./public.js').Readable<T>}\n */\nexport function derived(stores, fn, initial_value) {\n\tconst single = !Array.isArray(stores);\n\t/** @type {Array<import('./public.js').Readable<any>>} */\n\tconst stores_array = single ? [stores] : stores;\n\tif (!stores_array.every(Boolean)) {\n\t\tthrow new Error('derived() expects stores as input, got a falsy value');\n\t}\n\tconst auto = fn.length < 2;\n\treturn readable(initial_value, (set, update) => {\n\t\tlet started = false;\n\t\tconst values = [];\n\t\tlet pending = 0;\n\t\tlet cleanup = noop;\n\t\tconst sync = () => {\n\t\t\tif (pending) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcleanup();\n\t\t\tconst result = fn(single ? values[0] : values, set, update);\n\t\t\tif (auto) {\n\t\t\t\tset(result);\n\t\t\t} else {\n\t\t\t\tcleanup = is_function(result) ? result : noop;\n\t\t\t}\n\t\t};\n\t\tconst unsubscribers = stores_array.map((store, i) =>\n\t\t\tsubscribe(\n\t\t\t\tstore,\n\t\t\t\t(value) => {\n\t\t\t\t\tvalues[i] = value;\n\t\t\t\t\tpending &= ~(1 << i);\n\t\t\t\t\tif (started) {\n\t\t\t\t\t\tsync();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tpending |= 1 << i;\n\t\t\t\t}\n\t\t\t)\n\t\t);\n\t\tstarted = true;\n\t\tsync();\n\t\treturn function stop() {\n\t\t\trun_all(unsubscribers);\n\t\t\tcleanup();\n\t\t\t// We need to set this to false because callbacks can still happen despite having unsubscribed:\n\t\t\t// Callbacks might already be placed in the queue which doesn't know it should no longer\n\t\t\t// invoke this derived store.\n\t\t\tstarted = false;\n\t\t};\n\t});\n}\n\n/**\n * Takes a store and returns a new one derived from the old one that is readable.\n *\n * https://svelte.dev/docs/svelte-store#readonly\n * @template T\n * @param {import('./public.js').Readable<T>} store  - store to make readonly\n * @returns {import('./public.js').Readable<T>}\n */\nexport function readonly(store) {\n\treturn {\n\t\tsubscribe: store.subscribe.bind(store)\n\t};\n}\n\nexport { get_store_value as get };\n","export const getParamFromUrl = (param: string, url: string): string | null => {\n    if (!url.includes('?')) {\n        return null;\n    }\n\n    const params = new URLSearchParams(url.split('?')[1]);\n\n    return params.get(param);\n}\n\nexport const mapDataToFormData = (data: any, formData: FormData | null = null): FormData => {\n    let fData: FormData = formData ?? new FormData();\n\n    Object.keys(data).forEach(key => {\n        appendObjectToFormData(fData, data[key], key);\n    });\n\n    return fData;\n}\n\nconst appendObjectToFormData = (formData: FormData, data: { [key: string]: any }, parentKey: string = '') => {\n    if (data && typeof data === 'object' && !(data instanceof Date) && !(data instanceof File)) {\n        Object.keys(data).forEach(key => {\n            appendObjectToFormData(formData, data[key], parentKey ? `${parentKey}[${key}]` : key);\n        });\n    } else {\n        const value = data == null ? '' : data;\n\n        formData.append(parentKey, value as string);\n    }\n}\n\nexport const sanitizeColumnSelector = ( name: string ) => {\n    return name.replace(/\\./g, '\\\\.');\n}\n\nexport const withCooldown = <T extends (...args: any[]) => void>(callback: T, delay = 1000): T => {\n    let isCoolingDown = false;\n\n    return function (this: any, ...args: any[]) {\n        if (isCoolingDown) return;\n        isCoolingDown = true;\n        callback.apply(this, args);\n        setTimeout(() => {\n            isCoolingDown = false;\n        }, delay);\n    } as T;\n}"],"names":["subscriber_queue","readable","value","start","writable","noop","stop","subscribers","set","new_value","safe_not_equal","run_queue","subscriber","i","update","fn","subscribe","run","invalidate","getParamFromUrl","param","url","mapDataToFormData","data","formData","fData","key","appendObjectToFormData","parentKey"],"mappings":"+CASA,MAAMA,EAAmB,CAAE,EAWpB,SAASC,EAASC,EAAOC,EAAO,CACtC,MAAO,CACN,UAAWC,EAASF,EAAOC,CAAK,EAAE,SAClC,CACF,CAWO,SAASC,EAASF,EAAOC,EAAQE,EAAM,CAE7C,IAAIC,EAEJ,MAAMC,EAAc,IAAI,IAIxB,SAASC,EAAIC,EAAW,CACvB,GAAIC,EAAeR,EAAOO,CAAS,IAClCP,EAAQO,EACJH,GAAM,CAET,MAAMK,EAAY,CAACX,EAAiB,OACpC,UAAWY,KAAcL,EACxBK,EAAW,CAAC,EAAG,EACfZ,EAAiB,KAAKY,EAAYV,CAAK,EAExC,GAAIS,EAAW,CACd,QAASE,EAAI,EAAGA,EAAIb,EAAiB,OAAQa,GAAK,EACjDb,EAAiBa,CAAC,EAAE,CAAC,EAAEb,EAAiBa,EAAI,CAAC,CAAC,EAE/Cb,EAAiB,OAAS,CAC/B,CACA,CAEA,CAMC,SAASc,EAAOC,EAAI,CACnBP,EAAIO,EAAGb,CAAK,CAAC,CACf,CAOC,SAASc,EAAUC,EAAKC,EAAab,EAAM,CAE1C,MAAMO,EAAa,CAACK,EAAKC,CAAU,EACnC,OAAAX,EAAY,IAAIK,CAAU,EACtBL,EAAY,OAAS,IACxBD,EAAOH,EAAMK,EAAKM,CAAM,GAAKT,GAE9BY,EAAIf,CAAK,EACF,IAAM,CACZK,EAAY,OAAOK,CAAU,EACzBL,EAAY,OAAS,GAAKD,IAC7BA,EAAM,EACNA,EAAO,KAER,CACH,CACC,MAAO,CAAE,IAAAE,EAAK,OAAAM,EAAQ,UAAAE,CAAW,CAClC,CC7Fa,MAAAG,EAAkB,CAACC,EAAeC,IACtCA,EAAI,SAAS,GAAG,EAIN,IAAI,gBAAgBA,EAAI,MAAM,GAAG,EAAE,CAAC,CAAC,EAEtC,IAAID,CAAK,EALZ,KAQFE,EAAoB,CAACC,EAAWC,EAA4B,OAAmB,CACpF,IAAAC,EAAkBD,GAAY,IAAI,SAEtC,cAAO,KAAKD,CAAI,EAAE,QAAeG,GAAA,CAC7BC,EAAuBF,EAAOF,EAAKG,CAAG,EAAGA,CAAG,CAAA,CAC/C,EAEMD,CACX,EAEME,EAAyB,CAACH,EAAoBD,EAA8BK,EAAoB,KAAO,CACrG,GAAAL,GAAQ,OAAOA,GAAS,UAAY,EAAEA,aAAgB,OAAS,EAAEA,aAAgB,MACjF,OAAO,KAAKA,CAAI,EAAE,QAAeG,GAAA,CACNC,EAAAH,EAAUD,EAAKG,CAAG,EAAGE,EAAY,GAAGA,CAAS,IAAIF,CAAG,IAAMA,CAAG,CAAA,CACvF,MACE,CACG,MAAAxB,EAAQqB,GAAe,GAEpBC,EAAA,OAAOI,EAAW1B,CAAe,CAAA,CAElD","x_google_ignoreList":[0]}